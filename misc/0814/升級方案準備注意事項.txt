升級到 Lightweight Charts v5 並實現完美 FVG 渲染 - 執行文檔
📋 執行摘要
將交易圖表系統從 Lightweight Charts v4.1.3 升級到 v5.0.0，並實現真正的自定義矩形 FVG 渲染，解決縮放失準問題。
🎯 目標

升級圖表庫：v4.1.3 → v5.0.0
實現 Custom Series API：使用 v5 的新功能
解決 FVG 縮放問題：完美的矩形渲染
為未來 20+ 指標奠定基礎：建立可擴展的架構

📝 具體執行步驟
第一階段：備份與準備
bash# 1. 備份現有文件
cp src/frontend/index.html src/frontend/index-v4-backup.html
cp src/frontend/index-v2.html src/frontend/index-v2-backup.html
cp src/frontend/fvg-renderer.js src/frontend/fvg-renderer-v4-backup.js
cp src/frontend/chart-manager.js src/frontend/chart-manager-v4-backup.js

# 2. 創建測試頁面
cp src/frontend/index-v2.html src/frontend/index-v5-test.html
第二階段：升級 Lightweight Charts
步驟 1：修改 HTML 文件
javascript// 檔案：src/frontend/index-v5-test.html
// 找到這段：
<script>
    function loadLightweightCharts() {
        const cdnList = [
            'https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js',
            // ...
        ];
    }
</script>

// 替換為：
<script>
    function loadLightweightCharts() {
        const cdnList = [
            // v5.0.0 CDN URLs
            'https://unpkg.com/lightweight-charts@5.0.0/dist/lightweight-charts.standalone.production.js',
            'https://cdn.jsdelivr.net/npm/lightweight-charts@5.0.0/dist/lightweight-charts.standalone.production.js',
            'https://cdnjs.cloudflare.com/ajax/libs/lightweight-charts/5.0.0/lightweight-charts.standalone.production.min.js'
        ];
    }
</script>
第三階段：實現新的 FVG Custom Series
步驟 2：創建新的 FVG 渲染器
javascript// 新檔案：src/frontend/fvg-renderer-v5.js

/**
 * Lightweight Charts v5 FVG Custom Series 實現
 * 解決縮放失準問題的完美矩形渲染
 */

class FVGCustomSeriesRenderer {
    constructor() {
        this._data = [];
    }

    draw(target, priceConverter) {
        const ctx = target.context;
        const timeConverter = target.timeScale;
        
        // 保存上下文狀態
        ctx.save();
        
        this._data.forEach(fvg => {
            this._drawFVG(ctx, fvg, timeConverter, priceConverter);
        });
        
        // 恢復上下文狀態
        ctx.restore();
    }
    
    _drawFVG(ctx, fvg, timeConverter, priceConverter) {
        // 轉換時間座標
        const x1 = timeConverter.timeToCoordinate(fvg.startTime);
        const x2 = timeConverter.timeToCoordinate(fvg.endTime);
        
        // 檢查是否在可視範圍內
        if (x1 === null || x2 === null) return;
        if (x2 < 0 || x1 > ctx.canvas.width) return;
        
        // 轉換價格座標
        const y1 = priceConverter.priceToCoordinate(fvg.upper);
        const y2 = priceConverter.priceToCoordinate(fvg.lower);
        
        if (y1 === null || y2 === null) return;
        
        // 計算矩形參數
        const x = Math.min(x1, x2);
        const y = Math.min(y1, y2);
        const width = Math.abs(x2 - x1);
        const height = Math.abs(y2 - y1);
        
        // 跳過太小的矩形
        if (width < 1 || height < 1) return;
        
        // 設置顏色
        const opacity = this._calculateOpacity(height);
        const baseColor = fvg.type === 'bull' 
            ? `rgba(76, 175, 80, ${opacity})`
            : `rgba(244, 67, 54, ${opacity})`;
        const borderColor = fvg.type === 'bull'
            ? `rgba(76, 175, 80, ${opacity * 2})`
            : `rgba(244, 67, 54, ${opacity * 2})`;
        
        // 繪製填充
        ctx.fillStyle = baseColor;
        ctx.fillRect(x, y, width, height);
        
        // 繪製邊框
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 0.5, y + 0.5, width - 1, height - 1);
    }
    
    _calculateOpacity(pixelHeight) {
        // 根據像素高度計算透明度
        if (pixelHeight > 100) return 0.25;
        if (pixelHeight > 50) return 0.20;
        return 0.15;
    }
    
    update(data) {
        this._data = data;
    }
}

class FVGCustomSeries {
    constructor() {
        this.renderer = new FVGCustomSeriesRenderer();
    }
    
    priceValueBuilder(plotRow) {
        return plotRow.value;
    }
    
    isWhitespace(data) {
        return data.value === undefined;
    }
    
    renderer() {
        return this.renderer;
    }
}

class FVGRendererV5 {
    constructor(chart, candlestickSeries) {
        this.chart = chart;
        this.candlestickSeries = candlestickSeries;
        this.customSeries = null;
        this.fvgSeries = new FVGCustomSeries();
        this.isVisible = true;
        this.currentTimeframe = 'M15';
    }
    
    render(fvgs, currentTimeframe = 'M15', playbackMode = false) {
        this.currentTimeframe = currentTimeframe;
        
        // 清除舊的系列
        if (this.customSeries) {
            this.chart.removeSeries(this.customSeries);
            this.customSeries = null;
        }
        
        if (!this.isVisible || !fvgs || fvgs.length === 0) {
            return;
        }
        
        // 過濾太小的FVG
        const filteredFvgs = fvgs.filter(fvg => {
            const height = Math.abs(fvg.top - fvg.bot);
            return height >= 1.0;
        });
        
        // 準備數據
        const timeStep = ConfigUtils.getTimeframeSeconds(currentTimeframe);
        const fvgData = filteredFvgs.map(fvg => ({
            startTime: fvg.left_time || fvg.time,
            endTime: (fvg.left_time || fvg.time) + 40 * timeStep,
            upper: Math.max(fvg.top, fvg.bot),
            lower: Math.min(fvg.top, fvg.bot),
            type: fvg.type,
            id: fvg.id
        }));
        
        // 創建自定義系列
        try {
            this.customSeries = this.chart.addCustomSeries(this.fvgSeries, {
                priceScaleId: 'right',
                lastValueVisible: false,
                priceLineVisible: false,
            });
            
            // 更新數據
            this.fvgSeries.renderer().update(fvgData);
            
            // 觸發重繪
            const dummyData = [{ time: Date.now() / 1000, value: 0 }];
            this.customSeries.setData(dummyData);
            
        } catch (error) {
            console.error('Custom Series 創建失敗:', error);
            // 降級到舊版渲染
            this.fallbackRender(filteredFvgs, currentTimeframe);
        }
    }
    
    fallbackRender(fvgs, timeframe) {
        console.warn('使用降級渲染方案');
        // 這裡可以保留原有的線條渲染作為備用
    }
    
    clearAll() {
        if (this.customSeries) {
            this.chart.removeSeries(this.customSeries);
            this.customSeries = null;
        }
    }
    
    toggle() {
        this.isVisible = !this.isVisible;
        if (!this.isVisible) {
            this.clearAll();
        }
        return this.isVisible;
    }
}

// 導出到全局
window.FVGRendererV5 = FVGRendererV5;
步驟 3：修改 ChartManager 使用新渲染器
javascript// 修改：src/frontend/chart-manager.js

class ChartManager {
    initialize(containerId) {
        // ... 原有代碼 ...
        
        // 檢測 Lightweight Charts 版本
        const version = this.detectLightweightChartsVersion();
        console.log('Lightweight Charts 版本:', version);
        
        // 根據版本選擇渲染器
        if (version >= 5) {
            console.log('使用 v5 FVG 渲染器');
            this.fvgRenderer = new FVGRendererV5(this.chart, this.candlestickSeries);
        } else {
            console.log('使用舊版 FVG 渲染器');
            this.fvgRenderer = new FVGRenderer(this.chart, this.candlestickSeries);
        }
    }
    
    detectLightweightChartsVersion() {
        // 檢測版本的方法
        if (typeof this.chart.addCustomSeries === 'function') {
            return 5;
        }
        return 4;
    }
}
第四階段：測試與調試
步驟 4：創建測試腳本
javascript// 新檔案：src/frontend/test-fvg-v5.js

function testFVGScaling() {
    console.log('=== FVG v5 縮放測試 ===');
    
    // 創建測試數據
    const testFVGs = [
        {
            id: 'test-1',
            type: 'bull',
            top: 7180,
            bot: 7164,
            left_time: Date.now() / 1000 - 7200,
            time: Date.now() / 1000 - 7200
        },
        {
            id: 'test-2',
            type: 'bear',
            top: 7148,
            bot: 7144,
            left_time: Date.now() / 1000 - 3600,
            time: Date.now() / 1000 - 3600
        }
    ];
    
    // 渲染 FVG
    window.app.chartManager.fvgRenderer.render(testFVGs, 'M15');
    
    // 測試不同縮放級別
    const tests = [
        { name: '放大時間軸', delay: 2000, action: () => {
            window.app.chart.timeScale().setVisibleLogicalRange({
                from: -50,
                to: 50
            });
        }},
        { name: '縮小時間軸', delay: 4000, action: () => {
            window.app.chart.timeScale().setVisibleLogicalRange({
                from: -200,
                to: 0
            });
        }},
        { name: '放大價格軸', delay: 6000, action: () => {
            window.app.chart.priceScale('right').applyOptions({
                autoScale: false,
                scaleRange: {
                    minValue: 7140,
                    maxValue: 7190
                }
            });
        }},
        { name: '恢復自動縮放', delay: 8000, action: () => {
            window.app.chart.priceScale('right').applyOptions({
                autoScale: true
            });
        }}
    ];
    
    tests.forEach(test => {
        setTimeout(() => {
            console.log(`測試: ${test.name}`);
            test.action();
        }, test.delay);
    });
}

// 頁面載入後自動執行測試
window.addEventListener('load', () => {
    setTimeout(testFVGScaling, 3000);
});
⚠️ 潛在問題與解決方案
1. API 兼容性問題
問題：v5 的 API 有重大變更
javascript// v4 寫法
chart.removeSeries(series);

// v5 可能需要
chart.removeSeries(series);  // 相同，但內部實現不同
解決方案：使用 try-catch 包裝關鍵操作
2. 時間座標系統變更
問題：v5 使用不同的時間處理
javascript// 確保時間格式正確
const time = Math.floor(timestamp); // 確保是整數秒
3. 自定義系列渲染性能
問題：大量 FVG 可能影響性能
解決方案：
javascript// 添加視窗裁剪優化
if (x2 < 0 || x1 > canvas.width) return; // 跳過畫面外的FVG
4. 高 DPI 螢幕支持
問題：Retina 螢幕可能顯示模糊
解決方案：
javascript// 在渲染器中處理 DPI
const dpr = window.devicePixelRatio || 1;
ctx.scale(dpr, dpr);
5. 舊版瀏覽器兼容
問題：IE11 或舊版 Chrome 不支持
解決方案：
javascript// 檢測瀏覽器支持
if (!window.ResizeObserver) {
    console.warn('瀏覽器不支持 ResizeObserver');
    // 使用 polyfill 或降級方案
}
📊 測試檢查清單

 FVG 在默認縮放下正確顯示
 時間軸放大時，FVG 保持矩形形狀
 時間軸縮小時，FVG 不會分離
 價格軸縮放時，FVG 高度正確調整
 切換時間框架時，FVG 正確重繪
 播放模式下，FVG 正確更新
 高 DPI 螢幕顯示清晰
 性能測試：100+ FVG 流暢渲染

🔄 回滾計劃
如果升級失敗：
bash# 恢復備份文件
cp src/frontend/index-v4-backup.html src/frontend/index.html
cp src/frontend/fvg-renderer-v4-backup.js src/frontend/fvg-renderer.js
cp src/frontend/chart-manager-v4-backup.js src/frontend/chart-manager.js
📝 給 Claude Code 的執行指令
任務：升級 Lightweight Charts 到 v5 並實現完美的 FVG 渲染

1. 備份階段：
   - 備份所有相關文件（見第一階段）
   - 創建 index-v5-test.html 測試頁面

2. 升級階段：
   - 修改 index-v5-test.html 中的 CDN 鏈接到 v5.0.0
   - 創建 fvg-renderer-v5.js（使用提供的代碼）
   - 修改 chart-manager.js 添加版本檢測

3. 實現階段：
   - 實現 FVGCustomSeriesRenderer 類
   - 實現 draw 方法處理座標轉換
   - 添加 DPI 縮放支持

4. 測試階段：
   - 創建 test-fvg-v5.js 測試腳本
   - 執行縮放測試
   - 驗證所有檢查清單項目

5. 部署階段：
   - 確認測試通過後，將 index-v5-test.html 內容複製到 index-v2.html
   - 更新 HTML 載入新的渲染器文件

注意事項：
- 保持向後兼容（使用版本檢測）
- 所有新代碼都要有 try-catch 錯誤處理
- 保留降級方案（fallbackRender）
- 測試高 DPI 螢幕支持
🎯 成功標準

FVG 在任何縮放級別都顯示為完整矩形
性能不低於現有實現
支持未來擴展（20+ 指標）
代碼可維護性提升