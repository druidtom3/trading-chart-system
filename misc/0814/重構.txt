P0（阻斷級）
1) 時間軸的單一真相（Single Source of Truth）
背景：前端要用 timeToIndex.get(left_time) 找出矩形左界。如果 FVG 的 left_time/time 和燭線陣列的 candle.time 單位不同（秒 vs 毫秒）或時區不同（UTC vs 本地），映射會失敗。

壞結果：get() 回 undefined → 這筆 FVG直接不畫。大量不畫時，畫面像「全部都沒了」。

做法：

後端：所有對外時間欄位（FVG 的 left_time、time，燭線的 DateTime 轉出）一律轉成 UTC 的 epoch 秒（整數）。

前端：燭線 time 也一律使用 UTC epoch 秒。

啟動自檢：初始化後 console.assert(Number.isInteger(candles[0].time) && candles[0].time < 1e11)；同時測一筆 FVG：assert(timeToIndex.has(fvg.left_time))。不過就直接報錯，不進渲染。

驗收：Network 面板抽查一筆 FVG 與一根 K 的時間，兩者位數一致（10位數秒、不是13位數毫秒），而且 timeToIndex.has(left_time) 為 true。

2) 播放切窗的口徑統一
背景：我們已改成「播放時只畫到目前播放時間的 FVG」。若有人把 cutoff 預設成 0 或沒初始化就拿來比較，born_time <= cutoff 永遠是 false。

壞結果：在播放模式/或誤判為播放模式時，所有 FVG 都被時間條件過濾掉，看起來像「完全沒 FVG」或「靠近右側才出現」。

做法：

非播放模式：不切窗（不看時間條件，直接畫所有未回補/未過期）。

播放模式：只畫 born_time = (left_time || time) 小於等於 playbackNow 的 FVG。

playbackNow 的預設值＝當前右端 K 的 time；絕對不要用 0 或 undefined 參與比較。

驗收：不播放時，歷史區域立刻看到所有未回補/未過期 FVG；播放時，拖動播放位置，只會新增或消失合理的 FVG，不會整片忽然為 0。

3) FVG 物件唯一 schema與語義（IDL）
背景：倉庫內同名欄位在不同檔案語義略有差（例如有時用 time 畫左界，有時用 left_time）。這會讓前後端邏輯不一致。

壞結果：去重、回補、渲染各自假設不同，交界面容易出錯。

做法：把 FVG 的資料模型固定為唯一結構（後端輸出、前端消費都照這份）：

scss
複製
編輯
id, type(bull|bear), top>bot, origin(three|gap),
idx(形成bar索引：three=R, gap=C), left_idx(左界L的索引),
time(形成bar秒), left_time(左界L的秒),
max_age,
filled, expired, filled_at?, expired_at?
不變式：top > bot（後端保證）、left_time 一定是 L 的時間（不再用 time 畫左界）。
前端收到後再 assert 一遍（遇到不合法直接丟錯）。

驗收：抽樣幾筆 FVG：top>bot 成立；三根與跳空的 left_time 都等於 L 的時間；畫面左界與 L 對齊。

4) 回補規則鎖定成「單根實體」；若要多根，只允許連續扣除版
背景：歷史上同時存在三種版本：單根實體、多根聯集（鬆）、多根連續扣除（嚴）。「聯集」會把中間有洞也當回補，導致 FVG「一出生就消失」。

壞結果：整批被誤判 filled，前端過濾掉 → 你看到 0。

做法：

預設只保留 單根實體完全覆蓋（[min(O,C), max(O,C)] 完整蓋住 [bot,top]），** wick 忽略**。

若要支援多根，把「連續扣除」作為唯一選項（每根用實體去扣剩餘區間；清單扣到空才算回補）。移除「聯集」實作。

tick_eps 保持很小（或 0）；避免寬鬆到幾乎任何觸碰都算回補。

是否納入未收 K 的實體，由 confirm_on_close 開關決定（預設 False 支持你要的「覆蓋→縮回→再出現」動態）。

驗收：

製造「上影線刺穿但實體沒覆蓋」：不回補。

製造「兩根實體連續把整段蓋滿」：多根模式下 回補；單根模式下 不回補。

製造「兩根實體上、下各蓋一半，中間有洞」：不回補。

5) 去重集中一處，gap 優先於 three
背景：重複的來源很多（滑動視窗、跳空+三根同時抓到、相鄰幾乎相同）。不同地方各自去重容易互相打架。

壞結果：

沒去重：畫面上重疊多層；

去重錯：整批被當重複刪掉。

做法：

只保留一個去重函式（統一規則）：同向且 IoU ≥ 0.8 視為重複；若來源一個 gap、一個 three → 留 gap；若同起源 → 留「較寬」。

呼叫時機只有兩次：①填補/過期前（先去掉重複再判斷）、②所有狀態更新後收尾一次。

seen_gap 的鍵設計為 (type, left_idx)（或 (type,left_time)），保證同一根跳空只留一個。

驗收：

製造「跳空同時滿足三根」：最後只剩 1 個（來源標示 gap）。

去重前後的計數遞減合理（不會變成 0 或負）。

6) max_age 的單一來源
背景：曾經有「後端 400、前端顯示 40」的分歧，解釋成本高、容易誤會。

壞結果：你以為 FVG 到期了，其實只是前端畫到 40 而已；或相反。

做法：每筆 FVG 都帶 max_age；前端渲染優先使用後端值（本地常數只當 fallback）。

驗收：你把後端 max_age 改為 60，前端不改任何常數，矩形自動延伸到 60 根。

P1（高優先：結構解耦與一致性）
7) 只保留一個偵測模組
背景：倉庫內曾有多個 fvg_detector.py 版本；同名函式邏輯不完全相同。

壞結果：修改 A 卻在跑 B；bug 無法重現、PR 難審。

做法：只保留 FVGDetector 一個類；所有參數透過建構子；對外只有 detect(df, return_filled=False)。其他都是私有工具方法（內部命名以 _ 起頭）。

驗收：後端呼叫點只 import 這一個；刪除/檢索不到舊版本檔案。

8) 左界（left）語義一致
背景：跳空有時拿 C 的時間當左界；三根拿 L。切換後畫面會偏一根。

做法：兩種型別左界一律取 L 的時間與索引（left_time/left_idx），矩形左邊也以此為準；形成點 idx/time 只用來做壽命起算與狀態追蹤。

驗收：跳空矩形的左邊與「缺口發生前的那根（L）」對齊，不再偏。

9) 前端渲染器單一責任
背景：目前渲染、篩選、播放狀態、圖形回收混在多個函式。

壞結果：行為飄；很難排查「到底哪個分支沒畫」。

做法：抽出 FVGRenderer 類：

setCandles(rows) 構建 timeToIndex；

setFVGs(list) 接後端結果；

setPlaybackTime(sec) 設播放位置（或 null 表非播放）；

render() 做三件事：篩選（依 P0-2 規則）→ 畫/更新（id -> shape）→ 清理多餘。
支援 addShape('rectangle')，沒有則退為兩條價線，對外都透明。

驗收：渲染相關只在這個類改動；其他文件不再直接新增/刪除 shape。

10) 偵測只在後端發生
背景：歷史上前端也做過即時偵測，跟後端口徑不同。

壞結果：播放與非播放顯示不一致；debug 難度加倍。

做法：以後端偵測為唯一來源；前端只做「時間窗裁剪」與「右界延伸到 cutoff」。要「邊播邊生」的效果，靠 left_time + cutoff，而不是前端再跑一次偵測。

驗收：前端不再出現 OHLC→判斷 FVG 的邏輯。

11) 穩定的 FVG id
背景：前端用 id 做 shape 的新增/更新/刪除；id 不穩就會重畫或殘影。

做法：後端以 (type, origin, left_time, round(top,N), round(bot,N)) 產生 hash 當 id；產 id 前先保證 top>bot。

驗收：同一筆 FVG在不同 API 回合 id 不變；矩形可被更新不會重畫。

12) confirm_on_close 明確化
背景：你要「覆蓋→縮回→再出現」；但有時想避免閃爍。

做法：後端提供 confirm_on_close：

False（預設）：包含未收盤那根做判斷（允許動態消失/再出現）。

True：只用已收盤的 K（穩定、不閃爍）。

驗收：切換開關，播放到一根「內部變化很大」K，行為如預期（False 會閃、True 不會）。

P2（中優先：品質/效能/觀測）
13) 最小單元測試集
三根多/空、跳空（只產生 1 個）、單根回補、多根連續回補（中間不能斷）、到期過期、去重（gap 優先）。

驗收：這些用例綠燈才允許合併 PR。

14) 觀測點
後端：detected_before_dedupe、after_dedupe、after_fill；第一筆 filled=True 的 FVG 記錄「被第幾根覆蓋」。

前端（dev 模式）：印出「candles 最右 time」、「第一筆 FVG left_time」、「cutoff」。

驗收：一旦又發生「全部不畫」，立刻能判斷是 A/ B/ C 哪一類問題。

15) 參數集中
把 max_age / iou_thresh / tick_eps / fill_mode / require_dir_continuity 透過後端配置一次下發；前端優先讀取，避免硬編不同常數。

驗收：只改後端配置即可改變前端行為。

16) 去重掃描優化
排序後僅比對相鄰同向，避免 O(n²)；保留兩次呼叫（P0-5）。

驗收：上千個 FVG 仍可在可接受時間內處理。

17) 資源回收
render() 後掃一遍 drawnMap，把不在 alive 集合的 shape 移除；播放停止時做一次全清。

驗收：長時間播放不會 shape 泄漏、記憶體穩定。

P3（低優先：易讀/流程）
18) 一致的命名與註解
left_* 永遠指左界 L；idx 永遠指「追蹤起算的那根」（three=R、gap=C）。

每個方法頂部寫「輸入/輸出/不變式」一句話註解。

驗收：靠檢視就能知道一段邏輯在講哪一根，不用來回對照。

19) Lint / 型別
後端：ruff + black + mypy；前端：eslint + prettier。

驗收：CI 裡不過就不能合併。

20) 文件單一來源
定義與偵測手冊只留一份；每次改動更新「變更記錄」（版本、內容、影響）。

驗收：新同事只看這份就能實作一致的偵測/顯示。

最後給你一個「落地順序」與「自我驗收清單」
落地順序（建議）
P0 全做（時間、切窗、schema、不變式、回補、去重、max_age）。

收斂後端成唯一偵測器（P1-7），同步左界語義（P1-8）。

抽出 FVGRenderer（P1-9），前端不再偵測（P1-10）。

加上單元測試與觀測點（P2-13/14）。

其餘優化與文件。

自我驗收（一次過）
任選三天 × 三個 timeframe：

非播放：看到合理數量的 FVG（未回補/未過期）；

播放：拖動播放位置，只會「合理新增/消失」，不會整片歸零。

刻意製造：

跳空＋三根同時成立 → 只留 1 個（gap）。

上影線刺穿但實體沒覆蓋 → 不回補。

兩根實體連續把整段蓋滿（中間無洞） → 回補（多根模式）。

把 candle time 暫改毫秒 → 前端啟動即報錯（自檢生效）。

去重前/後、填補前/後計數合理（整體遞減，不會突然 0）。